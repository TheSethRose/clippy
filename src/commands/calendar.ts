import { Command } from 'commander';
import { resolveAuth } from '../lib/auth.js';
import { getCalendarEvents, type CalendarEvent, type CalendarAttendee } from '../lib/owa-client.js';

function formatTime(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
}

function formatDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
}

function parseDate(day: string, baseDate: Date = new Date()): Date {
  const now = new Date(baseDate);

  switch (day.toLowerCase()) {
    case 'today':
      return now;
    case 'yesterday':
      now.setDate(now.getDate() - 1);
      return now;
    case 'tomorrow':
      now.setDate(now.getDate() + 1);
      return now;
    case 'monday':
    case 'tuesday':
    case 'wednesday':
    case 'thursday':
    case 'friday':
    case 'saturday':
    case 'sunday': {
      const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const targetDay = days.indexOf(day.toLowerCase());
      const currentDay = now.getDay();
      let diff = targetDay - currentDay;
      if (diff > 0) diff -= 7; // Go to previous occurrence
      now.setDate(now.getDate() + diff);
      return now;
    }
    default:
      // Try to parse as date
      const parsed = new Date(day);
      return isNaN(parsed.getTime()) ? now : parsed;
  }
}

function getDateRange(startDay: string, endDay?: string): { start: string; end: string; label: string } {
  const now = new Date();

  // Handle special range keywords
  switch (startDay.toLowerCase()) {
    case 'week':
    case 'thisweek': {
      const start = new Date(now);
      const dayOfWeek = start.getDay();
      const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Monday
      start.setDate(start.getDate() + diff);
      start.setHours(0, 0, 0, 0);
      const end = new Date(start);
      end.setDate(end.getDate() + 6);
      end.setHours(23, 59, 59, 999);
      return { start: start.toISOString(), end: end.toISOString(), label: 'This Week' };
    }
    case 'lastweek': {
      const start = new Date(now);
      const dayOfWeek = start.getDay();
      const diff = dayOfWeek === 0 ? -13 : -6 - dayOfWeek; // Last Monday
      start.setDate(start.getDate() + diff);
      start.setHours(0, 0, 0, 0);
      const end = new Date(start);
      end.setDate(end.getDate() + 6);
      end.setHours(23, 59, 59, 999);
      return { start: start.toISOString(), end: end.toISOString(), label: 'Last Week' };
    }
    case 'nextweek': {
      const start = new Date(now);
      const dayOfWeek = start.getDay();
      const diff = dayOfWeek === 0 ? 1 : 8 - dayOfWeek; // Next Monday
      start.setDate(start.getDate() + diff);
      start.setHours(0, 0, 0, 0);
      const end = new Date(start);
      end.setDate(end.getDate() + 6);
      end.setHours(23, 59, 59, 999);
      return { start: start.toISOString(), end: end.toISOString(), label: 'Next Week' };
    }
  }

  // Single day or start of range
  const startDate = parseDate(startDay);
  startDate.setHours(0, 0, 0, 0);

  if (endDay) {
    // Date range
    const endDate = parseDate(endDay, startDate);
    endDate.setHours(23, 59, 59, 999);

    const label = `${formatDate(startDate.toISOString())} - ${formatDate(endDate.toISOString())}`;
    return { start: startDate.toISOString(), end: endDate.toISOString(), label };
  }

  // Single day
  const endDate = new Date(startDate);
  endDate.setHours(23, 59, 59, 999);

  return {
    start: startDate.toISOString(),
    end: endDate.toISOString(),
    label: formatDate(startDate.toISOString())
  };
}

function getResponseIcon(response: string): string {
  switch (response) {
    case 'Accepted': return 'âœ“';
    case 'Declined': return 'âœ—';
    case 'TentativelyAccepted': return '?';
    case 'NotResponded': return 'Â·';
    case 'Organizer': return 'â˜…';
    default: return 'Â·';
  }
}

function displayEvent(event: CalendarEvent, verbose: boolean): void {
  const startTime = formatTime(event.Start.DateTime);
  const endTime = formatTime(event.End.DateTime);
  const location = event.Location?.DisplayName || '';
  const cancelled = event.IsCancelled ? ' [CANCELLED]' : '';

  if (event.IsAllDay) {
    console.log(`  ðŸ“… All day: ${event.Subject}${cancelled}`);
  } else {
    console.log(`  ${startTime} - ${endTime}: ${event.Subject}${cancelled}`);
  }

  if (location) {
    console.log(`     ðŸ“ ${location}`);
  }

  if (verbose) {
    // Show organizer if not self
    if (!event.IsOrganizer && event.Organizer?.EmailAddress?.Name) {
      console.log(`     ðŸ‘¤ Organizer: ${event.Organizer.EmailAddress.Name}`);
    }

    // Show attendees
    if (event.Attendees && event.Attendees.length > 0) {
      const attendeeList = event.Attendees
        .map((a: CalendarAttendee) => `${getResponseIcon(a.Status.Response)} ${a.EmailAddress.Name}`)
        .join(', ');
      console.log(`     ðŸ‘¥ ${attendeeList}`);
    }

    // Show categories
    if (event.Categories && event.Categories.length > 0) {
      console.log(`     ðŸ·ï¸  ${event.Categories.join(', ')}`);
    }

    // Show body preview if available
    if (event.BodyPreview) {
      const preview = event.BodyPreview.substring(0, 80).replace(/\n/g, ' ');
      console.log(`     ðŸ“ ${preview}${event.BodyPreview.length > 80 ? '...' : ''}`);
    }
  }
}

export const calendarCommand = new Command('calendar')
  .description('View calendar events')
  .argument('[start]', 'Start day: today, yesterday, tomorrow, monday-sunday, week, lastweek, nextweek, or YYYY-MM-DD', 'today')
  .argument('[end]', 'End day for range (optional)')
  .option('-v, --verbose', 'Show attendees and more details')
  .option('--json', 'Output as JSON')
  .option('--token <token>', 'Use a specific token')
  .option('-i, --interactive', 'Open browser to extract token automatically')
  .action(async (startDay: string, endDay: string | undefined, options: { json?: boolean; token?: string; interactive?: boolean; verbose?: boolean }) => {
    const authResult = await resolveAuth({
      token: options.token,
      interactive: options.interactive,
    });

    if (!authResult.success) {
      if (options.json) {
        console.log(JSON.stringify({ error: authResult.error }, null, 2));
      } else {
        console.error(`Error: ${authResult.error}`);
        console.error('\nRun `clippy login --interactive` to authenticate.');
      }
      process.exit(1);
    }

    const { start, end, label } = getDateRange(startDay, endDay);
    const result = await getCalendarEvents(authResult.token!, start, end);

    if (!result.ok || !result.data) {
      if (options.json) {
        console.log(JSON.stringify({ error: result.error?.message || 'Failed to fetch events' }, null, 2));
      } else {
        console.error(`Error: ${result.error?.message || 'Failed to fetch events'}`);
      }
      process.exit(1);
    }

    const events = result.data.filter(e => !e.IsCancelled);

    if (options.json) {
      console.log(JSON.stringify(events, null, 2));
      return;
    }

    console.log(`\nðŸ“† Calendar for ${label}`);
    console.log('â”€'.repeat(40));

    if (events.length === 0) {
      console.log('  No events scheduled.');
    } else {
      // Group by date for multi-day ranges
      const eventsByDate = new Map<string, CalendarEvent[]>();
      for (const event of events) {
        const dateKey = event.Start.DateTime.split('T')[0];
        if (!eventsByDate.has(dateKey)) {
          eventsByDate.set(dateKey, []);
        }
        eventsByDate.get(dateKey)!.push(event);
      }

      // Check if multiple days
      if (eventsByDate.size > 1) {
        for (const [dateKey, dayEvents] of eventsByDate) {
          const dayLabel = formatDate(new Date(dateKey).toISOString());
          console.log(`\n  ${dayLabel}`);
          for (const event of dayEvents) {
            displayEvent(event, options.verbose ?? false);
          }
        }
      } else {
        for (const event of events) {
          displayEvent(event, options.verbose ?? false);
        }
      }
    }
    console.log();
  });
